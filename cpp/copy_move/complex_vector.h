/*
 * complex_vector.h
 *
 *  Created on: May 26, 2019
 *      Author: akadar
 */

// [1] Stroustrup, Bjarne. A Tour of C++. Chapter 4, Addison-Wesley Professional, 2018


#ifndef COMPLEX_VECTOR_H_
#define COMPLEX_VECTOR_H_

namespace ali {

struct complex {
	double real;
	double imag;
};

class complex_vector {
public:

	// A constructor with no arguments is generated by the compiler by default [1].
	// However, if the user has defined another constructor (ordinary or copy),
	// the compiler will not generate the default constructor unless it is explicitly
	// asked to do so by using the default keyword.
	complex_vector();

	// ordinary constructor with 1 argument
	// The explicit keyword prevents implicit conversion from size_t to complex_vector.
	explicit complex_vector(size_t);

	// ordinary constructor with 2 arguments
	// The explicit keyword prevents implicit conversion from size_t to complex_vector.
	explicit complex_vector(size_t, complex);

	/* A copy constructor is generated by the compiler by default [1].
	 * However, the compiler generated one is only capable of a shallow member copy.
	 * If the class has pointers to memory locations then a user defined copy constructor
	 * is needed to do a deep copy.
	 */
	complex_vector(const complex_vector&);
	// There are 3 other function signatures for a copy constructor.
	// someClass( someClass& other );
	// someClass( volatile const someClass& other );
	// someClass( volatile someClass& other );

	// Declaring my own copy assignment to print a message
	complex_vector& operator=(const complex_vector&);

	void print();

	~complex_vector();
private:
	size_t n;
	complex* data;
};
}



#endif /* COMPLEX_VECTOR_H_ */
